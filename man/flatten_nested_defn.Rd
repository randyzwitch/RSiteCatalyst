% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/flatten_nested_defn.R
\name{flatten_nested_defn}
\alias{flatten_nested_defn}
\title{Flatten a nested definition return}
\usage{
flatten_nested_defn(x, d = 0L, out = list())
}
\arguments{
\item{x}{The return from a call to Segments.Get via \code{\link{Segments_Get}} 
with a named element of \emph{definition}}

\item{d}{Internal counter to track recursion iterations}

\item{out}{Accumulator for results}
}
\value{
A list, currently taking one of two possible patterns, both of which apply to single
homogeneous cases:

Nested rules, i.e. a definiton where \emph{rules} is nested within \emph{containers}, 
will return a list of length 2, with named elements of \code{res,rules}. 

Nested containers, i.e. a definitions where \emph{container} is nested within \emph{rules}, 
will return a list of length \emph{n}, where \emph{n} is the number of nested containers. 

Stacked segments are not meaningfully parsed, but they are flattened into a more readable 
structure (for now).
}
\description{
Flatten the definition return data structure for nested container(s) and rule(s)
}
\details{
This is still experimental, and is not guaranteed to work for all cases; see below. Furthermore, 
note that \emph{parse} should not be taken as literal-- this function more accurately attempts
to flatten the often-nested list-of-\code{data.frame}(s) that comprises the return when \emph{definition} 
is requested in the \emph{fields} argument of \code{Segments_Get}.

There remain (at least) two edge cases that are not handled; the base method (on Adobe's end) 
currently cannot parse certain definitions, namely those with a \emph{then} operator. 
In fact, when a single such segment is a part of a set of returns, via \emph{Segments.Get}, 
the entire \code{definition} type is \code{list}, rather than \code{data.frame}. Furthremore,
the return value for the unparsable \emph{definition(s)} is a message along the lines of e.g:

\itemize{
\item \code{failed converting segment definition: failed converting container rule: datetime-within}
}

This function will pass such cases through, untouched.

The second case involves complex nesting patterns, where a nested container contains nested rules
contains nested containers, and so forth. In the unlikely event it was necessary to create a segment
in such a manner to begin with, you are on your own when it comes to parsing, and this function
will error when it encounters these scenarios.
}
\note{
This function attempts to flatten a definition return, and should be used only
on single-row data frames.
}
\examples{
# TBD
}
