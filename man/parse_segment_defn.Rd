% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parse_segment_defn.R
\name{parse_segment_defn}
\alias{parse_segment_defn}
\title{Parse a segment definition from Segments_Get}
\usage{
parse_segment_defn(x, verbose = FALSE)
}
\arguments{
\item{x}{The return from a call to Segments.Get via \code{\link{Segments_Get}} 
with a named element of \emph{definition}}

\item{verbose}{Should the function communicate the number of iterations
required to parse each definition? Defaults to \code{FALSE}}
}
\value{
A list, currently taking one of two possible patterns, both of which apply to single
homogeneous cases:

Nested rules, i.e. a definiton where \emph{rules} is nested within \emph{containers}, 
will return a list of length 2, with named elements of \code{res,rules}. 

Nested containers, i.e. a definitions where \emph{container} is nested within \emph{rules}, 
will return a list of length \emph{n}, where \emph{n} is the number of nested containers. 

Stacked segments are not meaningfully parsed, but they are flattened into a more readable 
structure (for now).
}
\description{
For a call to Segments_Get where 'definition' is requested, attempt to parse (flatten) the return
}
\details{
This is still experimental, and is not guaranteed to work for all cases; see below. Furthermore, 
note that \emph{parse} should not be taken as literal-- this function more accurately attempts
to flatten the often-nested list-of-\code{data.frame}(s) that comprises the return when \emph{definition} 
is requested in the \emph{fields} argument of \code{Segments_Get}.

There remain (at least) two edge cases that are not handled; the base method (on Adobe's end) 
currently cannot parse certain definitions, namely those with a \emph{then} operator. 
In fact, when a single such segment is a part of a set of returns, via \emph{Segments.Get}, 
the entire \code{definition} type is \code{list}, rather than \code{data.frame}. Furthremore,
the return value for the unparsable \emph{definition(s)} is a message along the lines of e.g:

\itemize{
\item \code{failed converting segment definition: failed converting container rule: datetime-within}
}

This function will pass such cases through, untouched.

The second case involves complex nesting patterns, where a nested container contains nested rules
contains nested containers, and so forth. In the unlikely event it was necessary to create a segment
in such a manner to begin with, you are on your own when it comes to parsing, and this function
will error when it encounters these scenarios.
}
\examples{
# TBD
}
